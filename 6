#include "iostream"
#include "vector"
#include <list>
#include <queue>
#include "algorithm"
class ListGraph {
private:

    std::vector<std::list<int>> matrix;
    std::vector<int> colours;

public:

    ListGraph(int ver);

    ListGraph(const ListGraph& other);

    void AddEdge(int from, int to);

    int VerticesCount() const;

    void GetNextVertices(int vertex, std::vector<int> &vertices) const;

    void GetPrevVertices(int vertex, std::vector<int> &vertices) const ;

    void writecolours();

    void setColours(int v, int x);

    int getMatrixSize();

    int getColours(int v);

};


void ListGraph::AddEdge(int from, int to) {
    if(from==to) return;
    if (std::find(matrix[from].begin(), matrix[from].end(), to) == matrix[from].end()) {
        matrix[from].push_back(to);
    }
}

int ListGraph::VerticesCount() const {
    return matrix.size();
}

void ListGraph::GetNextVertices(int vertex, std::vector<int> &vertices) const {
    vertices = {matrix[vertex].begin(), matrix[vertex].end()};
}

void ListGraph::GetPrevVertices(int vertex, std::vector<int> &vertices) const {
    for(int i=0; i<matrix.size();i++){
        if (std::find(matrix[i].begin(), matrix[i].end(), vertex) != matrix[i].end()){
            vertices.push_back(i);
        }
    }
}

ListGraph::ListGraph(int ver) : matrix(ver) , colours(ver, 0){}

ListGraph::ListGraph(const ListGraph &other) : matrix(other.matrix) {}

void dfs(ListGraph* G, int u , std::vector<bool>& visited, std::vector<int>& order) {
    visited[u] = true;
    std::vector<int> next;
    G->GetNextVertices(u, next);
    for(int i=0;i<next.size();i++){
        if( !visited[next[i]] )
            dfs(G, next[i] , visited, order );
    }

    order.push_back(u);
}

void mainDFS(ListGraph* G, std::vector<bool>& visited, std::vector<int>& order){
    for( int i = 0; i < visited.size(); ++i ) {
        if (!visited[i]) {
            dfs(G, i, visited, order);
        }
    }
}

void dfs2(ListGraph* G, int u, std::vector<bool> &visited, int flg) {
    visited[u] = true;
    std::vector<int> next;
    G->GetNextVertices(u, next);
    for(int i=0;i<next.size();i++){
        if( !visited[next[i]] )
            dfs2(G, next[i] , visited, flg );
    }
    G->setColours(u, flg);
}

int secondDFS(ListGraph* G, std::vector<bool> &visited, std::vector<int> &order) {
    int flg=0;
    for( int i = order.size()-1; i >=0; i-- ) {
        if (!visited[order[i]]) {
            dfs2(G, order[i], visited, flg++);
        }
    }
    return flg;
}

void ListGraph::writecolours() {
    for(int i=0;i<matrix.size();i++){
        std::cout << i+1 <<") " <<colours[i] <<"  ";
    }
}

int ListGraph::getMatrixSize() {
    return matrix.size();
}

void ListGraph::setColours(int v, int x) {
    colours[v] = x;
}

int ListGraph::getColours(int v) {
    return colours[v];
}

int getans(ListGraph* G, int cnt) {
    if(cnt==1)
        return 0;
    std::vector<int> out(cnt, 0);
    std::vector<int> in(cnt, 0);
    for(int i=0;i<G->getMatrixSize();i++){
        std::vector<int> next;
        G->GetNextVertices(i, next);
        for(int j=0;j<next.size();j++){
            if(G->getColours(i)!=G->getColours(j)){
                out[G->getColours(i)]++;
                in[G->getColours(next[j])]++;
            }
        }
    }
    int a=0;
    int b=0;
    for(int i=0;i<cnt;i++){
        if(in[i]==0) a++;
        if(out[i]==0) b++;
    }
    //std::cout<<a<<b;
    return (a>b?a:b);
}


int solve(int n, int v, int* in){
    ListGraph G(n);
    ListGraph Grev(n);
    for(int i=0;i<v;i++){
        G.AddEdge(in[2*i]-1, in[2*i+1]-1);
        Grev.AddEdge(in[2*i+1]-1, in[2*i]-1);
    }

    std::vector<bool> visited(n, false);
    std::vector<int> order;

    mainDFS(&Grev, visited, order);

    for(int i=0;i<order.size();i++){
        //std::cout <<order[i]+1<<" ";
        visited[i]=false;
    }
    std::cout<<"\n";
    int cnt=secondDFS(&G, visited, order);

    //G.writecolours();

    //std::cout<<cnt;


    return getans(&G, cnt);
}

int main() {
    int n;
    int v;
    std::cin >> n;
    std::cin >> v;
    int* in = new int[2*v];
    for(int i=0;i<v;i++){
        std::cin >> in[2*i] >> in[2*i+1];
    }

    std::cout << solve(n, v, in);

    delete [] in;
    return 0;
}
