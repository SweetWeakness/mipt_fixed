/*Дано число N < 106 и последовательность целых чисел из [-231..231] длиной N.
Требуется построить бинарное дерево, заданное наивным порядком вставки.
Т.е., при добавлении очередного числа K в дерево с корнем root, если root→Key ≤ K, то узел K добавляется в правое поддерево root; иначе в левое поддерево root. Балансировку выполнять не требуется.

 1_2. Выведите элементы в порядке pre-order (сверху вниз).
*/

#include <iostream>
#include <vector>
#include <stack>


bool cmpData(int a, int b) {
    return a>b;
}

// Узел двоичного дерева с данными типа int.
template <typename T>
struct CBinaryNode {
public:
    T Data;
    CBinaryNode* Left; // NULL, если нет.
    CBinaryNode* Right; // NULL, если нет.

    CBinaryNode(T value);
    ~CBinaryNode();
    CBinaryNode(CBinaryNode* cbn);
    void preOrderTravers(CBinaryNode* root,std::vector<T>* ans);
    void Insert(T value,bool (*p)(T,T) );
};


template<typename T>
CBinaryNode<T>::CBinaryNode(T value) {
    Data=value;
    Left= nullptr;
    Right= nullptr;
}

template<typename T>
void CBinaryNode<T>::preOrderTravers(CBinaryNode *root, std::vector<T> *ans) {
    std::stack <CBinaryNode*> Stack;
    Stack.push(root);
    while(!Stack.empty()){
        root=Stack.top();
        Stack.pop();
        (*ans).push_back(root->Data);
        if(root->Right){
            Stack.push(root->Right);
        }
        if(root->Left){
            Stack.push(root->Left);
        }
    }
}

template<typename T>
CBinaryNode<T>::~CBinaryNode() {

}

template<typename T>
void CBinaryNode<T>::Insert(T value,bool (*p)(T,T)) {
    CBinaryNode* node=this;
    while(node!= nullptr){
        if( p(node->Data, value) )
            if(node->Left!= nullptr){
                node=node->Left;
            }else{
                node->Left = new CBinaryNode( value );
                return;
            }
        else
        if(node->Right!= nullptr){
            node=node->Right;
        }else{
            node->Right = new CBinaryNode( value );
            return;
        }
    }
}

template<typename T>
CBinaryNode<T>::CBinaryNode(CBinaryNode* node) {
    Data=node->Data;
    if(node->Left) Left=CBinaryNode(node->Left);
    if(node->Right) Right=CBinaryNode(node->Right);
}

template <typename T>
class Node{
private:
    CBinaryNode<T>* CBN;
public:
    Node(T value);
    ~Node();
    Node(Node* cbn);
    void preOrderTravers(Node* root,std::vector<T>* ans);
    void Insert(T value,bool (*p)(T,T) );
};

template<typename T>
Node<T>::Node(T value) {
    CBN=new CBinaryNode<T>(value);
}

template<typename T>
Node<T>::~Node() {
    std::stack <CBinaryNode<T>*> Stack;
    Stack.push(this->CBN);
    CBinaryNode<T>* root;
    while(!Stack.empty()){
        root=Stack.top();
        Stack.pop();
        if(root->Right){
            Stack.push(root->Right);
        }
        if(root->Left){
            Stack.push(root->Left);
        }
        delete root;
    }
}

template<typename T>
Node<T>::Node(Node *cbn) {
    CBN=CBinaryNode<T>(cbn);
}

template<typename T>
void Node<T>::preOrderTravers(Node *root, std::vector<T> *ans) {
    root->CBN->preOrderTravers(root->CBN, ans);
}

template<typename T>
void Node<T>::Insert(T value, bool (*p)(T, T)) {
    CBN->Insert(value, p);
}


template <typename T>
void tree(T* in, std::vector<T>* ans, int n, bool (*p)(T,T)){
    Node<T>* Node1=new Node<T>(in[0]);
    for(int i=1;i<n;i++){
        Node1->Insert(in[i],p);
    }

    Node1->preOrderTravers(Node1, ans);
    delete Node1;
}

int main() {
    int n;
    std::cin >>n;
    int* in=new int[n];
    for(int i=0;i<n;i++){
        std::cin >>in[i];
    }

    bool (*p)(int, int ) = &cmpData;

    std::vector<int> ans;
    tree(in, &ans, n, p);

    for(int i=0;i<n;i++){
        std::cout <<ans[i] <<" ";
    }

    delete in;

    return 0;
}
