/*Дано число N < 106 и последовательность целых чисел из [-231..231] длиной N.
Требуется построить бинарное дерево, заданное наивным порядком вставки.
Т.е., при добавлении очередного числа K в дерево с корнем root, если root→Key ≤ K, то узел K добавляется в правое поддерево root; иначе в левое поддерево root. Балансировку выполнять не требуется.

 1_2. Выведите элементы в порядке pre-order (сверху вниз).
*/

#include <iostream>
#include <vector>
#include <stack>

// Узел двоичного дерева с данными типа int.
template <typename T>
class CBinaryNode {
private:
    T Data;
    CBinaryNode* Left; // NULL, если нет.
    CBinaryNode* Right; // NULL, если нет.

public:
    CBinaryNode(T value);
    ~CBinaryNode();
    void preOrderTravers(CBinaryNode* root,std::vector<T>* ans);
    void Insert(T value );
};

template<typename T>
CBinaryNode<T>::CBinaryNode(T value) {
    Data=value;
    Left= nullptr;
    Right= nullptr;
}


template<typename T>
void CBinaryNode<T>::preOrderTravers(CBinaryNode *root, std::vector<T> *ans) {
    std::stack <CBinaryNode*> Stack;
    Stack.push(root);
    while(!Stack.empty()){
        root=Stack.top();
        Stack.pop();
        (*ans).push_back(root->Data);
        if(root->Right){
            Stack.push(root->Right);
        }
        if(root->Left){
            Stack.push(root->Left);
        }
    }
}

template<typename T>
CBinaryNode<T>::~CBinaryNode() {
    std::stack <CBinaryNode*> Stack;
    Stack.push(this);
    CBinaryNode* root;
    while(!Stack.empty()){
        root=Stack.top();
        Stack.pop();
        if(root->Right){
            Stack.push(root->Right);
        }
        if(root->Left){
            Stack.push(root->Left);
        }
        delete root;
    }
}

template<typename T>
void CBinaryNode<T>::Insert(T value) {
    CBinaryNode* node=this;
    while(node!= nullptr){
        if( node->Data > value )
            if(node->Left!= nullptr){
                node=node->Left;
            }else{
                node->Left = new CBinaryNode( value );
                return;
            }
        else
        if(node->Right!= nullptr){
            node=node->Right;
        }else{
            node->Right = new CBinaryNode( value );
            return;
        }
    }
}

template <typename T>
void tree(T* in, std::vector<T>* ans, int n){
    CBinaryNode<T>* Node=new CBinaryNode<T>(in[0]);
    for(int i=1;i<n;i++){
        Node->Insert(in[i]);
    }

    Node->preOrderTravers(Node, ans);
    delete Node;
}

int main() {
    int n;
    std::cin >>n;
    int* in=new int[n];
    for(int i=0;i<n;i++){
        std::cin >>in[i];
    }

    std::vector<int> ans;
    tree(in, &ans, n);

    for(int i=0;i<n;i++){
        std::cout <<ans[i] <<" ";
    }

    delete in;

    return 0;
}
