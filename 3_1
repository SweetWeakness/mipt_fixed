/*Дано число N < 106 и последовательность целых чисел из [-231..231] длиной N.
Требуется построить бинарное дерево, заданное наивным порядком вставки.
Т.е., при добавлении очередного числа K в дерево с корнем root, если root→Key ≤ K, то узел K добавляется в правое поддерево root; иначе в левое поддерево root. Балансировку выполнять не требуется.

 1_2. Выведите элементы в порядке pre-order (сверху вниз).
*/

#include <iostream>
#include <vector>
#include <stack>


bool cmpData(int a, int b) {
    return a>b;
}

// Узел двоичного дерева с данными типа int.
template <typename T>
class CBinaryNode {
private:
    T Data;
    CBinaryNode* Left; // NULL, если нет.
    CBinaryNode* Right; // NULL, если нет.

public:
    CBinaryNode(T value);
    ~CBinaryNode();
    CBinaryNode* Copy();
    void preOrderTravers(CBinaryNode* root,std::vector<T>* ans);
    void Insert(T value,bool (*p)(T,T) );
    CBinaryNode* getLeft();
    CBinaryNode* getRight();
};

template<typename T>
CBinaryNode<T> *CBinaryNode<T>::getLeft() {
    return this->getLeft();
}

template<typename T>
CBinaryNode<T> *CBinaryNode<T>::getRight() {
    return this->getRight();
}

template<typename T>
CBinaryNode<T>::CBinaryNode(T value) {
    Data=value;
    Left= nullptr;
    Right= nullptr;
}

template<typename T>
void CBinaryNode<T>::preOrderTravers(CBinaryNode *root, std::vector<T> *ans) {
    std::stack <CBinaryNode*> Stack;
    Stack.push(root);
    while(!Stack.empty()){
        root=Stack.top();
        Stack.pop();
        (*ans).push_back(root->Data);
        if(root->getRight()){
            Stack.push(root->getRight());
        }
        if(root->getLeft()){
            Stack.push(root->getLeft());
        }
    }
}

template<typename T>
CBinaryNode<T>::~CBinaryNode() {
    std::stack <CBinaryNode*> Stack;
    Stack.push(this);
    CBinaryNode* root;
    while(!Stack.empty()){
        root=Stack.top();
        Stack.pop();
        if(root->getRight()){
            Stack.push(root->getRight());
        }
        if(root->getLeft()){
            Stack.push(root->getLeft());
        }
        delete root;
    }
}

template<typename T>
void CBinaryNode<T>::Insert(T value,bool (*p)(T,T)) {
    CBinaryNode* node=this;
    while(node!= nullptr){
        if( p(node->Data, value) )
            if(node->getLeft()!= nullptr){
                node=node->getLeft();
            }else{
                node->getLeft() = new CBinaryNode( value );
                return;
            }
        else
        if(node->getRight()!= nullptr){
            node=node->getRight();
        }else{
            node->getRight() = new CBinaryNode( value );
            return;
        }
    }
}

template<typename T>
CBinaryNode<T>*CBinaryNode<T>::Copy() {
    CBinaryNode* copy=new CBinaryNode(this->Data);
    if(this->getLeft()) copy->getLeft()=this->getLeft()->Copy();
    if(this->getRight()) copy->getRight()=this->getRight()->Copy();
    return copy;
}


template <typename T>
void tree(T* in, std::vector<T>* ans, int n, bool (*p)(T,T)){
    CBinaryNode<T>* Node=new CBinaryNode<T>(in[0]);
    for(int i=1;i<n;i++){
        Node->Insert(in[i],p);
    }

    Node->preOrderTravers(Node, ans);
    delete Node;
}

int main() {
    int n;
    std::cin >>n;
    int* in=new int[n];
    for(int i=0;i<n;i++){
        std::cin >>in[i];
    }

    bool (*p)(int, int ) = &cmpData;

    std::vector<int> ans;
    tree(in, &ans, n, p);

    for(int i=0;i<n;i++){
        std::cout <<ans[i] <<" ";
    }

    delete in;

    return 0;
}
