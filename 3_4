/*
 * Даны неотрицательные целые числа n,k и массив целых чисел из [0..10^9] размера n. Требуется найти k-ю порядковую статистику. т.е. напечатать число, которое бы стояло на позиции с индексом k (0..n-1) в отсортированном массиве. Напишите нерекурсивный алгоритм.
Требования к дополнительной памяти: O(n). Требуемое среднее время работы: O(n).
Функцию Partition следует реализовывать методом прохода двумя итераторами в одном направлении. Описание для случая прохода от начала массива к концу:
Выбирается опорный элемент. Опорный элемент меняется с последним элементом массива.
Во время работы Partition в начале массива содержатся элементы, не бОльшие опорного. Затем располагаются элементы, строго бОльшие опорного. В конце массива лежат нерассмотренные элементы. Последним элементом лежит опорный.
Итератор (индекс) i указывает на начало группы элементов, строго бОльших опорного.
Итератор j больше i, итератор j указывает на первый нерассмотренный элемент.
Шаг алгоритма. Рассматривается элемент, на который указывает j. Если он больше опорного, то сдвигаем j.
Если он не больше опорного, то меняем a[i] и a[j] местами, сдвигаем i и сдвигаем j.
В конце работы алгоритма меняем опорный и элемент, на который указывает итератор i.

3_4. Реализуйте стратегию выбора опорного элемента “случайный элемент”. Функцию Partition реализуйте методом прохода двумя итераторами от конца массива к началу.

 */



#include <iostream>

bool compare(int a, int b){
    return a>b;
}

void swap(int* a, int* b){
    int tmp=*a;
    *a=*b;
    *b=tmp;
}

template <typename T>
int Partition(T* in,int left,int right, bool (*cmp)(T, T)){
    if(left==right) return left;
    int pivot=rand()%(right-left+1)+left;
    swap(&in[pivot], &in[right]);
    int i=right-1;
    int j=right-1;
    while(j>=left){
        if(cmp(in[j], in[right])){
            if(i!=j) {
                swap(&in[i], &in[j]);
            }
            i--;
        }
        j--;

    }
    swap(&in[i+1], &in[right]);
    return i+1;
}

template <typename T>
int find(T* in, int k, int n, bool (*p)(T, T)){
    int left=0;
    int right=n-1;
    int pvt;

    do{
        pvt=Partition(in, left, right, p);
        if(pvt<k){
            left=pvt+1;
        }
        if(pvt>k){
            right=pvt-1;
        }
    }while(pvt!=k);

    return in[pvt];
}

int main() {
    int n;
    int k;
    std::cin >> n >> k;
    int* in=new int[n];
    for(int i=0;i<n;i++){
        std::cin >> in[i];
    }

    bool (*p)(int, int) = &compare;

    std::cout << find(in, k, n, p);

    return 0;
}
