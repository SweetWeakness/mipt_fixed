/*
 * Во всех задачах данного раздела необходимо реализовать и использовать локальную пирамидальную сортировку (без использования дополнительной памяти). Общее время работы алгоритма O(n log n).

 *
 * 2_2. Современники.
Группа людей называется современниками если был такой момент, когда они могли собраться вместе. Для этого в этот момент каждому из них должно было  уже исполниться 18 лет, но ещё не исполниться 80 лет.
Дан список Жизни Великих Людей. Необходимо получить максимальное количество современников. В день 18летия человек уже может принимать участие в собраниях, а в день 80летия и в день смерти уже не может.
Замечание. Человек мог не дожить до 18-летия, либо умереть в день 18-летия. В этих случаях принимать участие в собраниях он не мог.

 */

#include <iostream>

struct date{
public:
    int year;
    int month;
    int day;
    bool born;

    void set(int d, int m, int y){
        day=d;
        year=y;
        month=m;
    }
    date(int d, int m, int y, bool x){
        day=d;
        year=y;
        month=m;
        born=x;
    }

    bool equal(date* one, date* two){
        return (one->year==two->year)&&(one->month==two->month)&&(one->day==two->day);
    }

    void writed(){
        std::cout <<day<<" "<<month<<" "<<year<<(born?"+1":"-1")<<" | ";
    }

};

bool compare(date* one, date* two){// Is 1st bigger than 2nd
    if(one->year>two->year) return true;
    if(one->year<two->year) return false;

    if(one->month>two->month) return true;
    if(one->month<two->month) return false;

    if(one->day>two->day)return true;
    if(one->day<two->day)return false;

    return (one->born>two->born);
}

struct Man{
public:
    date* born;
    date* die;
    Man(int d_born, int m_born, int y_born, int d_die, int m_die, int y_die){
        born=new date(d_born, m_born, y_born, true);
        die=new date(d_die, m_die, y_die, false);
    }
    Man(){
        die=new date(0,0,0,0);
        born=new date(0,0,0,0);
    }
    ~Man(){
        delete [] die;
        delete [] born;
    }
    bool makeValid(){
        born->year+=18;
        if(compare(die, born)){
            date* death80=new date(born->day, born->month, born->year+62, false);
            if(compare(die,death80)){
                die->set(death80->day,death80->month ,death80->year);
            }
            delete(death80);
            return  true;
        }
        return false;
    }
    void write(){
        born->writed();
        die->writed();
        std::cout<<"\n";
    }
};

void swap(date* a, date* b){
    int tmp=b->day;
    b->day=a->day;
    a->day=tmp;

    tmp=b->month;
    b->month=a->month;
    a->month=tmp;

    tmp=b->year;
    b->year=a->year;
    a->year=tmp;

    bool flg=b->born;
    b->born=a->born;
    a->born=flg;

}

template <typename T>
void SiftDown(int i,T** arr, int n, bool (*compare)(T*, T*)) {
    int left = 2 * i + 1;
    int right = 2 * i + 2;
// Ищем большего сына, если такой есть.
    int largest = i;
    if( left <n && compare(arr[left], arr[i]) )
        largest = left;
    if( right < n && compare(arr[right], arr[largest]) )
        largest = right;
// Если больший сын есть, то проталкиваем корень в него.
    if( largest != i ) {
        swap( arr[i], arr[largest] );
        SiftDown( largest, arr, n , compare);
    }
}


template <typename T>
void HeapSort(T** arr, int size, bool (*p)(T*, T*)){

    for(int i=size/2-1;i>=0;i--){
        SiftDown(i, arr, size, p);
    }

        for(int i=size;i>0;i--){
            swap(arr[0], arr[i-1]);
            SiftDown(0, arr, i-1, p);
        }

};

int count(Man** in, int n, bool (*p)(date*, date*)){

    int cnt=0;
    int max=0;
    date** dates=new date*[2*n];
    for(int i=0;i<n;i++){
        dates[2*i]=in[i]->die;
        dates[2*i+1]=in[i]->born;
    }
    HeapSort(dates, 2*n, p);
   // std::cout<<"now its sorting...";

    for(int i=0;i<2*n;i++){
        if(dates[i]->born){
            cnt++;
        }else{
            cnt--;
        }
        if(cnt>max){
            max=cnt;
        }
    }

    delete [] dates;

    return max;


}

int main() {
    int n;
    std::cin >> n;
    Man** in=new Man*[n];

    int a,b,c,d,e,f;
    Man* tmp;
    int k=0;
    for(int i=0;i<n;i++){
        std::cin >> a>>b>>c>>d>>e>>f;
        tmp = new Man(a,b,c,d,e,f);
        if(tmp->makeValid()){
            in[k++]=tmp;
        }
        //tmp->write();
    }

    bool (*p)(date*, date*) = &compare;

    std::cout<<count(in, k, p);

    for(int i=0;i<n;i++){
        delete in[i];
    }

    return 0;
}
