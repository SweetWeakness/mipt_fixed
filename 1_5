/*Решение всех задач данного раздела предполагает использование стека. Способ реализации стека может быть любым (список/динамический массив).
 *
5_1. Скобочная последовательность.
Дан фрагмент последовательности скобок, состоящей из символов (){}[].
Требуется определить, возможно ли продолжить фрагмент в обе стороны, получив корректную последовательность.
Длина исходной последовательности ≤ 800000.
Формат входных данных. Строка, содержащая символы (){}[] и, возможно, перевод строки.
Формат выходных данных. Если возможно - вывести минимальную корректную последовательность, иначе - напечатать "IMPOSSIBLE".*/

#include <iostream>
#include <string>

template <typename T>
class Deque{
private://поля
    int head;//индекст head
    int tail;//индекст tail
    T* buffer;//сам буфер
    int bufSize;//размер
    int bufElem;//кол-во эл-ов

public:
    Deque* Copy();
    void writeout();
    void PushFront(T NumIn);
    void PushBack(T NumIn);
    void DelFront();
    T Front();
    void DelBack();
    T Back();
    Deque(int size);//конструктор
    ~Deque();//диструктор
    bool checkSpace();//проверка на наличие места под новый элемент
    void bufExpand();//расширение массива в 2 раза
    void bufPrepare();
    int checkEmpty();
};

template<typename T>
Deque<T> *Deque<T>::Copy() {
    Deque* Copy=new Deque(bufSize);
    for(int i=0;i<bufSize;i++) {
        Copy->buffer[i] = this->buffer[i];
    }
    Copy->head=this->head;
    Copy->tail=this->tail;
    Copy->bufElem=this->bufElem;
    return Copy;
}

template<typename T>
void Deque<T>::writeout() {
    for(int i=0;i<bufElem;i++){
        std::cout << buffer[(tail-1-i+bufSize)%bufSize];
    }
}

template<typename T>
void Deque<T>::PushFront(T NumIn) {
    bufPrepare();
    int tmp=(head==0?bufSize-1:head-1);
    buffer[tmp]=NumIn;
    head=tmp;
    bufElem+=1;
}

template<typename T>
void Deque<T>::PushBack(T NumIn) {
    bufPrepare();
    buffer[tail]=NumIn;
    tail=(tail+1)%bufSize;
    bufElem+=1;
}

template<typename T>
void Deque<T>::DelFront() {
    if(bufElem!=0) {
        head = (head+1) % bufSize;
        bufElem-=1;
    }
}

template<typename T>
T Deque<T>::Front() {
    if(bufElem!=0) {
        return buffer[head];
    }else{
        return NULL;
    }
}

template<typename T>
void Deque<T>::DelBack() {
    if(bufElem!=0){
        tail = (tail-1+bufSize)%bufSize;
        bufElem-=1;
    }
}

template<typename T>
T Deque<T>::Back() {
    if(bufElem!=0){
        return buffer[(tail-1+bufSize)%bufSize];
    }else{
        return NULL;
    }
}

template<typename T>
Deque<T>::Deque(int size) {
    this->buffer=new T[size];
    this->bufSize=size;
    this->bufElem=0;
    this->head=0;
    this->tail=0;
}

template<typename T>
Deque<T>::~Deque() {
    delete [] buffer;
}

template<typename T>
bool Deque<T>::checkSpace() {
    return !(bufSize==bufElem);
}

template<typename T>
void Deque<T>::bufExpand() {
    T* bufTemp=new char[bufSize*2];

    if(tail<=head){

        for(int i=head;i<bufSize;i++){
            bufTemp[i-head]=buffer[i];
        }
        int tmp=bufSize-head;
        for(int i=0;i<tail;i++){
            bufTemp[tmp+i]=buffer[i];
        }

    }else{

        for(int i=0;i<bufSize;i++){
            bufTemp[i]=buffer[i];
        }

    }

    delete [] buffer;
    buffer=bufTemp;
    bufSize*=2;
    head=0;
    tail=bufElem;
}

template<typename T>
void Deque<T>::bufPrepare() {
    if(!checkSpace()){
        bufExpand();
    }
}

template<typename T>
int Deque<T>::checkEmpty() {
    return bufElem==0;
}

int getlast(char* in){//кол-во скобок всего ( поиск )
    int i=0;
    while(in[i]==')'||in[i]=='}'||in[i]==']'||in[i]=='['||in[i]=='{'||in[i]=='('){
        i++;
    }
    return i;
}


template <typename  T>
bool brackets(Deque<T>* deq, Deque<T>* ans, T op, T ed){
    if (deq->checkEmpty()) {
        ans->PushBack(op);
        ans->PushFront(ed);
        return true;
    } else {
        if (deq->Back() == op) {
            ans->PushFront(ed);
            deq->DelBack();
            return true;
        } else {
            return false;
        }
    }
}

template <typename T>
bool closed(Deque<T>* deq, Deque<T>* ans, char in) {//процедура дял закрытых скобок
    if (in == '}') return brackets(deq, ans, '{', '}');
    if (in == ']') return brackets(deq, ans, '[', ']');
    if (in == ')')return brackets(deq, ans, '(', ')');
}

template <typename T>
void checkString(T* in, Deque<T>* ans, bool* flg) {//кол-во скобок
    Deque<T>*deq = new Deque<T>(2);
    int n = getlast(in);
    char tmp;
    for (int i = 0; (i < n) && *flg; i++) {
        if (in[i] == '(') {
            ans->PushFront('(');
            deq->PushBack('(');
        } else {
            if (in[i] == '{') {
                ans->PushFront('{');
                deq->PushBack('{');
            } else {
                if (in[i] == '[') {
                    ans->PushFront('[');
                    deq->PushBack('[');
                } else {
                    *flg = closed(deq, ans, in[i]);
                }
            }
        }
    }

    while(!deq->checkEmpty()){
        tmp=deq->Back();
        if(tmp=='(') {
            ans->PushFront(')');
        }
        if(tmp=='['){
            ans->PushFront(']');
        }
        if(tmp=='{'){
            ans->PushFront('}');
        }
        deq->DelBack();
    }

    deq->writeout();

    delete deq;
}


int main() {
    char* in=new char[800001];
    Deque<char>* ans=new Deque<char>(2);
    scanf("%s",in);
    bool flg=true;

    checkString(in, ans, &flg);

    if(flg){
        ans->writeout();
    }else{
        std::cout << "IMPOSSIBLE";
    }

    delete [] in;
    delete ans;

    return 0;
}
