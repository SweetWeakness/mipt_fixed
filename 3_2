/*Дано число/*Дано число N < 106 и последовательность пар целых чисел из [-231..231] длиной N.
Построить декартово дерево из N узлов, характеризующихся парами чисел {Xi, Yi}.
Каждая пара чисел {Xi, Yi} определяет ключ Xi и приоритет Yi в декартовом дереве.
Добавление узла в декартово дерево выполняйте второй версией алгоритма, рассказанного на лекции:
При добавлении узла (x, y) выполняйте спуск по ключу до узла P с меньшим приоритетом. Затем разбейте найденное поддерево по ключу x так, чтобы в первом поддереве все ключи меньше x, а во втором больше или равны x. Получившиеся два дерева сделайте дочерними для нового узла (x, y). Новый узел вставьте на место узла P.

Построить также наивное дерево поиска по ключам Xi методом из задачи 1.

 2_2. Вычислить количество узлов в самом широком слое декартового дерева и количество узлов в самом широком слое наивного дерева поиска. Вывести их разницу. Разница может быть отрицательна.
*/

#include <iostream>
#include <queue>
#include <stack>
using namespace std;

bool cmpData(int a, int b) {
    return a>b;
}

bool cmpPriority(int a, int b) {
    return a>b;
}

// Узел двоичного дерева с данными
template <typename T>
class CBinaryNode {
private:
    T Data;
    CBinaryNode* Left;
    CBinaryNode* Right;

public:
    CBinaryNode* Copy();
    CBinaryNode(T value);
    ~CBinaryNode();
    CBinaryNode();
    void Insert(T value,bool (*p1)(T,T));
    CBinaryNode* getLeft();
    CBinaryNode* getRight();
};

template<typename T>
CBinaryNode<T>*CBinaryNode<T>::Copy() {
    CBinaryNode* copy=new CBinaryNode(this->Data);
    if(this->Left) copy->Left=this->Left->Copy();
    if(this->Right) copy->Right=this->Right->Copy();
    return copy;
}

template<typename T>
CBinaryNode<T>::CBinaryNode(T value) {
    Data=value;
    Left= nullptr;
    Right= nullptr;
}

template<typename T>
CBinaryNode<T>::CBinaryNode() {
    Data=NULL;
    Left=nullptr;
    Right=nullptr;
}

template<typename T>
void CBinaryNode<T>::Insert(T value,bool (*p1)(T,T)) {
    CBinaryNode* node=this;
    if (node == nullptr){
        node=new CBinaryNode(value);
    }
    while(node!= nullptr){
        if( p1(node->Data, value) )
            if(node->Left!= nullptr){
                node=node->Left;
            }else{
                node->Left = new CBinaryNode( value );
                return;
            }
        else
        if(node->Right!= nullptr){
            node=node->Right;
        }else{
            node->Right = new CBinaryNode( value );
            return;
        }
    }
}

template<typename T>
CBinaryNode<T>::~CBinaryNode() {
    stack <CBinaryNode*> Stack;
    Stack.push(this);
    CBinaryNode* root;
    while(!Stack.empty()){
        root=Stack.top();
        Stack.pop();
        if(root->Right){
            Stack.push(root->Right);
        }
        if(root->Left){
            Stack.push(root->Left);
        }
        delete root;
    }
}

template<typename T>
CBinaryNode<T> *CBinaryNode<T>::getLeft() {
    return this->Left;
}

template<typename T>
CBinaryNode<T> *CBinaryNode<T>::getRight() {
    return this->Right;
}

//декартово дерево (Ку-Ре-Во)
template <typename T, typename P>
class TNode{
private:
    T Data;
    P Priority;
    TNode* Left;
    TNode* Right;

public:
    TNode(T value, P priority);
    TNode();
    TNode* Copy();
    ~TNode();
    TNode* getLeft();
    TNode* getRight();
    T getData();
    P getPriority();
};

template<typename T, typename P>
TNode<T, P>::TNode(T value, P priority) {
    Data=value;
    Priority=priority;
    Left=nullptr;
    Right=nullptr;
}

template<typename T, typename P>
TNode<T, P>::TNode() {
    Data=NULL;
    Priority=NULL;
    Left=nullptr;
    Right=nullptr;
}

template<typename T, typename P>
TNode<T, P> *TNode<T, P>::Copy() {
    TNode<T, P>* copy=new TNode<T, P>(this->Data, this->Priority);
    if(this->Left) copy->Left=this->Left->Copy();
    if(this->Right) copy->Right=this->Right->Copy();
    return copy;
}

template<typename T, typename P>
TNode<T, P>::~TNode() {
    stack <TNode*> Stack;
    Stack.push(this);
    TNode<T, P>* root;
    while(!Stack.empty()){
        root=Stack.top();
        Stack.pop();
        if(root->Right){
            Stack.push(root->Right);
        }
        if(root->Left){
            Stack.push(root->Left);
        }
        delete root;
    }
}

template<typename T, typename P>
TNode<T, P> *TNode<T, P>::getLeft() {
    return this->Left;
}

template<typename T, typename P>
TNode<T, P> *TNode<T, P>::getRight() {
    return this->Right;
}

template<typename T, typename P>
T TNode<T, P>::getData() {
    return this->Data;
}

template<typename T, typename P>
P TNode<T, P>::getPriority() {
    return this->Priority;
}


// Разрезание декартового дерева по ключу.
template <typename T, typename P>
void Split( TNode<T,P>* currentNode, T key, TNode<T,P>*& left, TNode<T,P>*& right,bool (*p1)(T,T),bool (*p2)(P,P) ) {
    if( currentNode == 0 ) {
        left = 0;
        right = 0;
    } else if( !p1(currentNode->getData(), key)) {
        Split( currentNode->getRight(), key, currentNode->getRight(), right,p1,p2 );
        left = currentNode;
    } else {
        Split( currentNode->getLeft(), key, left, currentNode->getLeft(),p1,p2 );
        right = currentNode;
    }
}

template <typename T, typename P>
void Insert(T Data, P Priority, TNode<T, P>*& CNode, bool (*p1)(T,T), bool (*p2)(P,P)) {
    if (CNode == nullptr) {
        CNode = new TNode<T, P>(Data, Priority);
        return;
    }
    if (p2(CNode->getPriority(), Priority)) {
        if (p1(CNode->getData(), Data)) {
            Insert(Data, Priority, CNode->getLeft(),p1,p2);
        }
        else {
            Insert(Data, Priority, CNode->getRight(),p1,p2);
        }
    }
    else {
        TNode<T, P>* newNode = new TNode<T, P>(Data, Priority);
        Split(CNode, Data, newNode->Left, newNode->Right,p1,p2);
        CNode = newNode;
    }
    return;
}

template <class T>
int findWidth(T *&node)
{
    queue<T> Tree;
    T* tmp = new T();
    long int maxWidth = 1;
    Tree.push(*node);
    int len = 1;
    int n = 1;
    while (!Tree.empty()) {
        if (maxWidth < Tree.size()){
            maxWidth = Tree.size();
        }
        for (int i = 0; i < n; i++) {
            *tmp = Tree.front();
            Tree.pop();
            len--;
            if (tmp->getLeft() != nullptr) {
                Tree.push(*tmp->getLeft());
                len++;
            }
            if (tmp->getRight() != nullptr) {
                Tree.push(*tmp->getRight());
                len++;
            }
        }
        n = len;
    }
    delete tmp;
    return maxWidth;
}


template <typename T, typename P>
int tree(T* inData, P* inPrior, int n, bool (*p1)(T,T), bool (*p2)(P,P)){
    TNode<T,P>* Node2=new TNode<T,P>(inData[0], inPrior[0]);
    CBinaryNode<T>* Node1=new CBinaryNode<T>(inData[0]);
    for(int i=1;i<n;i++){
        Insert(inData[i],inPrior[i], Node2,p1,p2);
        Node1->Insert(inData[i],p1);
    }

    int ans=findWidth(Node2)-findWidth(Node1);
    delete Node1;
    delete Node2;
    return ans;
}

int main() {
    int n;
    std::cin >>n;
    int* inData=new int[n];
    int* inPrior=new int[n];
    for(int i=0;i<n;i++){
        std::cin >>inData[i];
        std::cin >>inPrior[i];
    }

    bool (*p1)(int, int ) = &cmpData;
    bool (*p2)(int, int ) = &cmpPriority;


    std::cout << tree(inData, inPrior, n, p1, p2);

    delete inData;
    delete inPrior;

    return 0;
}
