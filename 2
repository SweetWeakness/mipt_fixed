#include "iostream"
#include "vector"
#include <list>
#include <queue>
#include "algorithm"


class ListGraph {
private:

    std::vector<std::list<int>> matrix;
    std::vector<int> colours;

public:

    ListGraph(int ver);

    ListGraph(const ListGraph& other);

    void AddEdge(int from, int to);

    int VerticesCount() const;

    void GetNextVertices(int vertex, std::vector<int> &vertices) const;

    void GetPrevVertices(int vertex, std::vector<int> &vertices) const ;

    int getColour(int vertex);

    void setColour(int v, int x);

    void prepare();
};


void ListGraph::AddEdge(int from, int to) {
    if (std::find(matrix[from].begin(), matrix[from].end(), to) == matrix[from].end()){
        matrix[from].push_back(to);
    }
    if (std::find(matrix[to].begin(), matrix[to].end(), from) == matrix[to].end()){
        matrix[to].push_back(from);
    }
}

int ListGraph::VerticesCount() const {
    return matrix.size();
}

void ListGraph::GetNextVertices(int vertex, std::vector<int> &vertices) const {
    vertices = {matrix[vertex].begin(), matrix[vertex].end()};
}

void ListGraph::GetPrevVertices(int vertex, std::vector<int> &vertices) const {
    for(int i=0; i<matrix.size();i++){
        if (std::find(matrix[i].begin(), matrix[i].end(), vertex) != matrix[i].end()){
            vertices.push_back(i);
        }
    }
}

ListGraph::ListGraph(int ver) : matrix(ver) , colours(ver, 0){}

ListGraph::ListGraph(const ListGraph &other) : matrix(other.matrix) {}

int ListGraph::getColour(int vertex) {
    return colours[vertex];
}

int findCycle(ListGraph* G, int v) {
    G->prepare();
    std::vector<int> back(G->VerticesCount(), -1);
    std::vector<int> high(G->VerticesCount(), 0);
    std::queue<int> q;
    q.push(v);
    G->setColour(v, 1);
    while(!q.empty()){
        int curr = q.front();
        std::vector<int> next;
        G->GetNextVertices(curr, next);
        q.pop();
        for (int i=0;i<next.size();i++) {
            int n=next[i];
            if (G->getColour(n) == 0) {
                q.push(n);
                G->setColour(n, 1);
                back[n] = curr;
                high[n] = high[curr] + 1;
            } else {
                if (n != back[curr]) {
                    return high[curr] + high[n] + 1;
                }
            }
        }
    }


    return -1;
}

void ListGraph::prepare() {
    for(int i=0;i<colours.size();i++)
        colours[i]=0;
}

void ListGraph::setColour(int v, int x) {
    colours[v] = x;
}


int solve(int n, int v, int* in){
    ListGraph G=ListGraph(n);
    for(int i=0;i<v;i++){
        G.AddEdge(in[2*i], in[2*i+1]);
    }
    int min, tmp;
    min=n+1;

    for(int i=0;i<n;i++){
        tmp=findCycle((&G), i);
        if (tmp<min && tmp !=-1) min=tmp;
    }

    if (min == n+1){
        return -1;
    }else{
        return min;
    }
}

int main() {
    int n;
    int v;
    std::cin >> n;
    std::cin >> v;
    int* in = new int[2*v];
    for(int i=0;i<v;i++){
        std::cin >> in[2*i] >> in[2*i+1];
    }

    std::cout << solve(n, v, in);

    delete [] in;
    return 0;
}
